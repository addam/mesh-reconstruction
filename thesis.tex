\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[top=3.5cm, bottom=3cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsfonts, amsmath, amssymb, rotate}
\begin{document}
\title{3D Surface Reconstuction from Calibrated Video\\
Bachelor thesis}
\author{Adam Dominec}
\date{\today}
\maketitle
\section{Introduction}
\section{Algorithms}
\subsection{Polygonization}
\subsubsection{Alpha Shapes}
Alpha shape calculation will be the first approach considered in this category, because it is a nice computational-geometry-textbook example. Its input is a set of $n$ points in (generally) $d$-dimensional space and an additional positive parameter $\alpha$. In the $3$-dimensional case, its output is a set of triangle faces, whose vertices are a subset of the input. The value of $\alpha$ is expressed in units of length; particularly, we will call $\alpha$-sphere a sphere of radius $\alpha$\footnote{For implementation reasons, some sources define $\sqrt{\alpha}$ to be the radius; other define ${}^1\!/_\alpha$ to be the radius, which allows to incorporate convex hull cleanly and even give meaning to negative $\alpha$.}. A triangle is an output face if and only if its vertices are touched by an $\alpha$-sphere whose interior does not contain any points from the input. As $\alpha$ approaches infinity, the output degenerates to convex hull calculation; if it approaches zero, output will be empty. A good choice of $\alpha$ is very important in order to get useful results, but as we will see, the algorithm can be adapted to make a guess for suitable $\alpha$ on its own.

A straightforward implementation has not only the problem of trying $\binom n d$ possible faces, but mainly that classical search structures (such as octrees) can be very ineffective for unevenly distributed points. Surprisingly, it is faster to calculate a more complex structure: the Delaunay triangulation, that can be later easily degraded to any specific $\alpha$-shape. Delaunay triangulation of a $d$-dimensional point set is a set of $d$-dimensional simplices whose vertices are a subset of the input and whose circumscribing spheres do not contain any other points from the input.

Various algorithms for calculating Delaunay triangulation are used in practice. As dimensionality of the problem increases to three or more, it appears to be reasonably simple and effective to use an incremental approach. Delaunay triangulation of $d+1$ points is the simplex itself. Adding a new point to an existing Delaunay triangulation consists of finding its nearest neighbour in the current structure, determining the affected area around it and appropriately altering the corresponding simplices. If points are inserted in order sorted by one coordinate, all these three tasks can be carried out in linear expected time \textsuperscript{[citation needed: CGAL algorithm]}. The resulting triangulation contains $O(n^2)$ simplices in the worst case, so this incremental algorithm may be considered optimal. By practical measurements for a set of uniformly random points, the performance appears to be even better, close to linear dependency \cite[p.~439--458]{liu02}.

Conversion to alpha shape is then straightforward. To every simplex $s_i$ of the triangulation there corresponds a radius of circumscribed sphere; let us call it $\alpha_{\max}(s_i)$. Similarly, every triangle face $f_i$ of the triangulation has a circumradius, which we can call $\alpha_{\min}(f_i)$. A face $f_i$ should be member of the output for a given $\alpha$ if and only if $\alpha_{\min}(f_i) \le \alpha \le \alpha_{\max}(s_i)$ for $s_i \in \{\text{neighbour simplices of }f_i\}$; each face has at most two neighbour simplices, faces included in the c.

We observe that as $\alpha$ changes, the resulting $\alpha$-shape changes only at finitely many thresholds, namely the circumradii of all faces and simplices of the triangulation. And clearly, as $\alpha$ decreases, the count of disconnected components monotonically increases. Thanks to that, we can choose a desired count of disconnected components and use bisection to search for the smallest $\alpha$ possible. We generally wish to keep $\alpha$ as low as possible, because such $\alpha$-shape retains most details of the original point cloud. On the other hand, we cannot allow it fall too low, because such $\alpha$-shape would degenerate to an empty set. To prevent that, we force the output to make a single component; but as discussed below, that is a questionable constraint.

My program uses the CGAL library \cite{cgal} for calculating the alpha shape and the underlying Delaunay triangulation, because its implementation has shown to be fast and very robust.

Alpha shapes provide an excellent tool for triangulation of points uniformly distributed over a connected volume: most probably, the $\alpha$ parameter will be guessed right, and the corresponding $\alpha$-shape will tightly enclose the whole volume \textsuperscript{[citation needed: tests on a Stanford bunny]}. However, if the point cloud contains more detail in a small portion of the input, it will be smoothed out due to the global character of the $\alpha$ value. In particular, the result is nearly useless if input consists of several separate parts: $\alpha$ must be chosen large enough to bridge them all, thus removing all details whatsoever. The same applies in the presence of outliers, so if alpha shapes are to be used for polygonization, point filtering stage is of enormous importance.

The performance could probably also be improved by using another heuristic for guessing the right $\alpha$, for example maximizing the total face count.

Because the triangulation produces points only on (supposed) scene surfaces, there may be an empty volume inside of solids in the scene and alpha shapes may tend to produce a small inner shell along with the outer one. Although it is harmless to the subsequent reconstruction steps, it is an evidence that alpha shapes do not use all the available information. Each point in the point cloud has been created by reconstruction from several cameras spread roughly in one direction, and so they should not give rise to a surface faced oppositely. Some of the following, more involved algorithms address this problem implicitly.

[It can also be seen as a limitation of alpha shapes that they can only pick vertices from the input; however, I don't know yet what algorithms I'll compare it to, so I wait with writing this paragraph.]

\begin{thebibliography}{9}
\bibitem{cgal}
	CGAL,
	Computational Geometry Algorithms Library,
	http://www.cgal.org 
\bibitem{liu02}
  Liu, Y. and Snoeyink, J.:
  \emph{A comparison of five implementations of 3D delaunay tessellation}.
  Combinatorial and Computational Geometry,
  2002.

\end{thebibliography}
\end{document}
